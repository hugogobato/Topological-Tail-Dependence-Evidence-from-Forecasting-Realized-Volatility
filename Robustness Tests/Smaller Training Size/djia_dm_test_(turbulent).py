# -*- coding: utf-8 -*-
"""DJIA DM test (turbulent).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jdEPBXYltfGOCyatf1IKyFOCoJakCbHy
"""

import pandas as pd
import numpy as np

def dm_test(actual_lst, pred1_lst, pred2_lst, h = 1, crit="MSE", power = 2):
    # Routine for checking errors
    def error_check():
        rt = 0
        msg = ""
        # Check if h is an integer
        if (not isinstance(h, int)):
            rt = -1
            msg = "The type of the number of steps ahead (h) is not an integer."
            return (rt,msg)
        # Check the range of h
        if (h < 1):
            rt = -1
            msg = "The number of steps ahead (h) is not large enough."
            return (rt,msg)
        len_act = len(actual_lst)
        len_p1  = len(pred1_lst)
        len_p2  = len(pred2_lst)
        # Check if lengths of actual values and predicted values are equal
        if (len_act != len_p1 or len_p1 != len_p2 or len_act != len_p2):
            rt = -1
            msg = "Lengths of actual_lst, pred1_lst and pred2_lst do not match."
            return (rt,msg)
        # Check range of h
        if (h >= len_act):
            rt = -1
            msg = "The number of steps ahead is too large."
            return (rt,msg)
        # Check if criterion supported
        if (crit != "MSE" and crit != "QLIKE" and crit != "MAD" and crit != "poly"):
            rt = -1
            msg = "The criterion is not supported."
            return (rt,msg)
        # Check if every value of the input lists are numerical values
        from re import compile as re_compile
        comp = re_compile("^\d+?\.\d+?$")
        def compiled_regex(s):
            """ Returns True is string is a number. """
            if comp.match(s) is None:
                return s.isdigit()
            return True
        for actual, pred1, pred2 in zip(actual_lst, pred1_lst, pred2_lst):
            is_actual_ok = compiled_regex(str(abs(actual)))
            is_pred1_ok = compiled_regex(str(abs(pred1)))
            is_pred2_ok = compiled_regex(str(abs(pred2)))
            if (not (is_actual_ok and is_pred1_ok and is_pred2_ok)):
                msg = "An element in the actual_lst, pred1_lst or pred2_lst is not numeric."
                rt = -1
                return (rt,msg)
        return (rt,msg)

    # Error check
    error_code = error_check()
    # Raise error if cannot pass error check
    if (error_code[0] == -1):
        raise SyntaxError(error_code[1])
        return
    # Import libraries
    from scipy.stats import t
    import collections
    import pandas as pd
    import numpy as np

    # Initialise lists
    e1_lst = []
    e2_lst = []
    d_lst  = []

    # convert every value of the lists into real values
    actual_lst = pd.Series(actual_lst).apply(lambda x: float(x)).tolist()
    pred1_lst = pd.Series(pred1_lst).apply(lambda x: float(x)).tolist()
    pred2_lst = pd.Series(pred2_lst).apply(lambda x: float(x)).tolist()

    # Length of lists (as real numbers)
    T = float(len(actual_lst))

    # construct d according to crit
    if (crit == "MSE"):
        for actual,p1,p2 in zip(actual_lst,pred1_lst,pred2_lst):
            e1_lst.append((actual - p1)**2)
            e2_lst.append((actual - p2)**2)
        for e1, e2 in zip(e1_lst, e2_lst):
            d_lst.append(e1 - e2)
    elif (crit == "MAD"):
        for actual,p1,p2 in zip(actual_lst,pred1_lst,pred2_lst):
            e1_lst.append(abs(actual - p1))
            e2_lst.append(abs(actual - p2))
        for e1, e2 in zip(e1_lst, e2_lst):
            d_lst.append(e1 - e2)
    elif (crit == "QLIKE"):
        for actual,p1,p2 in zip(actual_lst,pred1_lst,pred2_lst):
            e1_lst.append((actual/p1-np.log(actual/p1)-1))
            e2_lst.append((actual/p2-np.log(actual/p2)-1))
        for e1, e2 in zip(e1_lst, e2_lst):
            d_lst.append(e1 - e2)
    elif (crit == "poly"):
        for actual,p1,p2 in zip(actual_lst,pred1_lst,pred2_lst):
            e1_lst.append(((actual - p1))**(power))
            e2_lst.append(((actual - p2))**(power))
        for e1, e2 in zip(e1_lst, e2_lst):
            d_lst.append(e1 - e2)

    # Mean of d
    mean_d = pd.Series(d_lst).mean()

    # Find autocovariance and construct DM test statistics
    def autocovariance(Xi, N, k, Xs):
        autoCov = 0
        T = float(N)
        for i in np.arange(0, N-k):
              autoCov += ((Xi[i+k])-Xs)*(Xi[i]-Xs)
        return (1/(T))*autoCov
    gamma = []
    for lag in range(0,h):
        gamma.append(autocovariance(d_lst,len(d_lst),lag,mean_d)) # 0, 1, 2
    V_d = (gamma[0] + 2*sum(gamma[1:]))/T
    DM_stat=V_d**(-0.5)*mean_d
    harvey_adj=((T+1-2*h+h*(h-1)/T)/T)**(0.5)
    DM_stat = harvey_adj*DM_stat
    # Find p-value
    p_value = 2*t.cdf(-abs(DM_stat), df = T - 1)

    # Construct named tuple for return
    dm_return = collections.namedtuple('dm_return', 'DM p_value')

    rt = dm_return(DM = DM_stat, p_value = p_value)

    return rt

df=pd.read_excel("Forecasts turbulent.xlsx")

df=df[["Date", "Actuals","Forecast without PH", "Forecast with PH", "HAR", "HARX", "HARST - PH", "HARST (week)"]]

df.head()

"""# DM Test MSE"""

dm_test(df["Actuals"], df["Forecast without PH"], df["Forecast with PH"], h = 1, crit="MSE")

dm_test(df["Actuals"], df["HAR"], df["HARX"], h = 1, crit="MSE")

dm_test(df["Actuals"], df["HARST - PH"], df["HARST (week)"], h = 1, crit="MSE")

"""# DM Test MAE"""

dm_test(df["Actuals"], df["Forecast without PH"], df["Forecast with PH"], h = 1, crit="MAD")

dm_test(df["Actuals"], df["HAR"], df["HARX"], h = 1, crit="MAD")

dm_test(df["Actuals"], df["HARST - PH"], df["HARST (week)"], h = 1, crit="MAD")

"""# DM Test QLIKE"""

dm_test(df["Actuals"], df["Forecast without PH"], df["Forecast with PH"], h = 1, crit="QLIKE")

dm_test(df["Actuals"], df["HAR"], df["HARX"], h = 1, crit="QLIKE")

dm_test(df["Actuals"], df["HARST - PH"], df["HARST (week)"], h = 1, crit="QLIKE")

"""# MCS Test MSE"""

!pip install arch

df1=df
df1["Forecast without PH"]=(df1["Actuals"]-df1["Forecast without PH"])**2
df1["Forecast with PH"]=(df1["Actuals"]-df1["Forecast with PH"])**2
df1["HAR"]=(df1["Actuals"]-df1["HAR"])**2
df1["HARX"]=(df1["Actuals"]-df1["HARX"])**2
df1["HARST - PH"]=(df1["Actuals"]-df1["HARST - PH"])**2
df1["HARST (week)"]=(df1["Actuals"]-df1["HARST (week)"])**2

df1.head()

from arch.bootstrap import MCS

losses=df.drop(columns=["Date", "Actuals"])

mcs = MCS(losses, size=0.05, method="R", block_size=1109)
mcs.compute()
print("MCS P-values")
print(mcs.pvalues)
print("Included")
included = mcs.included
print(included)
print("Excluded")
excluded = mcs.excluded
print(excluded)

"""# MCS Test MAE"""

df=pd.read_excel("Forecasts turbulent.xlsx")
df=df[["Date", "Actuals","Forecast without PH", "Forecast with PH", "HAR", "HARX", "HARST - PH", "HARST (week)"]]
df1=df
df1["Forecast without PH"]=abs(df1["Actuals"]-df1["Forecast without PH"])
df1["Forecast with PH"]=abs(df1["Actuals"]-df1["Forecast with PH"])
df1["HAR"]=abs(df1["Actuals"]-df1["HAR"])
df1["HARX"]=abs(df1["Actuals"]-df1["HARX"])
df1["HARST - PH"]=abs(df1["Actuals"]-df1["HARST - PH"])
df1["HARST (week)"]=abs(df1["Actuals"]-df1["HARST (week)"])

losses=df.drop(columns=["Date", "Actuals"])

mcs = MCS(losses, size=0.05, method="R", block_size=1109)
mcs.compute()
print("MCS P-values")
print(mcs.pvalues)
print("Included")
included = mcs.included
print(included)
print("Excluded")
excluded = mcs.excluded
print(excluded)

"""# MCS Test QLIKE"""

df=pd.read_excel("Forecasts turbulent.xlsx")
df=df[["Date", "Actuals","Forecast without PH", "Forecast with PH", "HAR", "HARX", "HARST - PH", "HARST (week)"]]
df1=df
df1["Forecast without PH"]=(df1["Actuals"]/df1["Forecast without PH"])-np.log(df1["Actuals"]/df1["Forecast without PH"])-1
df1["Forecast with PH"]=(df1["Actuals"]/df1["Forecast with PH"])-np.log(df1["Actuals"]/df1["Forecast with PH"])-1
df1["HAR"]=(df1["Actuals"]/df1["HAR"])-np.log(df1["Actuals"]/df1["HAR"])-1
df1["HARX"]=(df1["Actuals"]/df1["HARX"])-np.log(df1["Actuals"]/df1["HARX"])-1
df1["HARST - PH"]=(df1["Actuals"]/df1["HARST - PH"])-np.log(df1["Actuals"]/df1["HARST - PH"])-1
df1["HARST (week)"]=(df1["Actuals"]/df1["HARST (week)"])-np.log(df1["Actuals"]/df1["HARST (week)"])-1

losses=df.drop(columns=["Date", "Actuals"])

mcs = MCS(losses, size=0.05, method="R", block_size=1109)
mcs.compute()
print("MCS P-values")
print(mcs.pvalues)
print("Included")
included = mcs.included
print(included)
print("Excluded")
excluded = mcs.excluded
print(excluded)

